---
title: "Dashboard Eleições Legislativas 2025"
format: 
  html:
    theme: cosmo
    toc: true
execute:
  echo: false
---

## Dados e tabela de vencedores por distrito

```{ojs}
d3 = require("d3@7")

// Ler ficheiros de dados
resultados = await FileAttachment("data/resultados.json").json()
distritosGeo = await FileAttachment("data/ContinenteDistritos_geo.geojson").json()

// Chaves base que não são partidos
baseKeys = new Set(["Inscritos", "Votantes", "Brancos", "Nulos", "VVE"])

// Lista de distritos (tudo menos "Total")
distritos = Object.keys(resultados.Inscritos).filter(d => d !== "Total")

// Lista de partidos = todas as chaves menos as de base
partidos = Object.keys(resultados).filter(k => !baseKeys.has(k))

// Cores por partido
partyColors = ({
  "AD": "#ff7f00",
  "PPD/PSD.CDS-PP": "#ff7f00",
  "PPD/PSD.CDS-PP.PPM": "#ff7f00",
  "PS": "#e41a1c",
  "CH": "#1e53a1ff",
  "IL": "#2ebce7ff",
  "B.E.": "#984ea3",
  "L": "#4daf4a",
  "PCP-PEV": "#1a9850",
  "PAN": "#00a6a6",
  "R.I.R.": "#f781bf",
  "VP": "#a6cee3",
  "ADN": "#fdbf6f",
  "E": "#ffed6f",
  "JPP": "#cab2d6",
  "MPT": "#b2df8a",
  "NC": "#6a3d9a",
  "ND": "#fb9a99",
  "PLS": "#ffff99",
  "PPM": "#1f78b4",
  "PCTP/MRPP": "#e31a1c",
  "PTP": "#a6cee3"
})

getPartyColor = p => partyColors[p] || "#bbb"

normalize = nome => nome.toUpperCase().trim()

// Função: vencedor por distrito
function winnerByDistrict() {
  const winners = {};
  for (const dist of distritos) {
    let bestParty = null;
    let bestVotes = -1;
    for (const p of partidos) {
      const votosPartido = resultados[p] || {};
      const votos = votosPartido[dist] != null ? votosPartido[dist] : 0;
      if (votos > bestVotes) {
        bestVotes = votos;
        bestParty = p;
      }
    }
    winners[dist] = { partido: bestParty, votos: bestVotes };
  }
  return winners;
}

winners = winnerByDistrict()

// winners com chaves normalizadas (para bater certo com o GeoJSON)
winnersNorm = Object.fromEntries(
  Object.entries(winners).map(([d, info]) => [normalize(d), info])
)

// Input reativo: distrito selecionado
viewof distritoSelecionado = Inputs.select(distritos, {
  label: "Distrito:",
  value: distritos[0]
})

// Tabela: votos de TODOS os partidos no distrito selecionado
viewof tabelaDistrito = Inputs.table(
  partidos.map(p => ({
    partido: p,
    votos: (resultados[p] || {})[distritoSelecionado] || 0
  })), 
  { sort: "votos", reverse: true }
)
```
## Vencedor por distrito (resumo nacional)

```{ojs}
// Tabela para confirmar vencedores por distrito
viewof tabelaVencedores = Inputs.table(
  distritos.map(d => ({
    distrito: d,
    partido: winners[d].partido,
    votos: winners[d].votos
  }))
)
```

## Mapa: Partido Mais Votado por Distrito

<div id="map-partido" style="height: 500px; margin-bottom: 1rem;"></div>

```{ojs}
L = require("leaflet@1.9.4")

// Injetar CSS do Leaflet
leafletCss = html`<link rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>`

// Como se chama o distrito no GeoJSON
nomeDistrito = f =>
normalize(
f.properties.DISTRITO ??
f.properties.Distrito ??
f.properties.NOME ??
f.properties.name
)

mapPartido = {
const map = L.map("map-partido").setView([39.5, -8], 6);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 18,
attribution: "© OpenStreetMap contributors"
}).addTo(map);

function style(feature) {
const nome = nomeDistrito(feature);
const info = winnersNorm[nome] || {};
return {
color: "#555",
weight: 1,
fillOpacity: 0.8,
fillColor: getPartyColor(info.partido)
};
}

function onEachFeature(feature, layer) {
const nome = nomeDistrito(feature);
const info = winnersNorm[nome] || {};
const partido = info.partido || "N/A";
const votos = info.votos ?? 0;


layer.bindTooltip(
  `${nome}<br>Vencedor: ${partido}<br>Votos: ${votos.toLocaleString("pt-PT")}`
);

layer.on("mouseover", () => layer.setStyle({ weight: 3 }));
layer.on("mouseout", () => layer.setStyle({ weight: 1 }));
layer.on("click", () => map.fitBounds(layer.getBounds()));


}

L.geoJSON(distritosGeo, { style, onEachFeature }).addTo(map);

return map;
}
```

## Mapa: Intensidade de Voto por Partido

```{ojs}
viewof partidoIntensidade = Inputs.select(partidos, {
label: "Partido (intensidade):",
value: "PS"
})

```

<div id="map-intensidade" style="height: 500px; margin-bottom: 1rem;"></div>

```{ojs}
mapIntensidade = {
const container = document.getElementById("map-intensidade");

// Se já existir um mapa neste div, removê-lo primeiro
if (container._leaflet_map) {
container._leaflet_map.remove();
}

const map = L.map(container).setView([39.5, -8], 6);
container._leaflet_map = map;

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 18,
attribution: "© OpenStreetMap contributors"
}).addTo(map);

// função auxiliar: encontrar o nome de distrito como existe em `resultados`
function distritoKey(feature) {
const rawName =
feature.properties.DISTRITO ??
feature.properties.Distrito ??
feature.properties.NOME ??
feature.properties.name;


const nomeNorm = normalize(rawName);

// procura nas chaves de `distritos` (Aveiro, Beja, Évora, ...)
const match = distritos.find(d => normalize(d) === nomeNorm);

// se encontrou, usa o nome “bonito” do JSON; senão, fica com o rawName
return match ?? rawName;


}

function style(feature) {
const key = distritoKey(feature); // ex: "Aveiro", "Viana do Castelo", ...


const votosPartido =
  (resultados[partidoIntensidade] || {})[key] || 0;

const totalValidos =
  (resultados["VVE"] || {})[key] || 1;

let ratio = votosPartido / totalValidos; // 0..1
ratio = ratio * 3;            // realça distritos mais fortes
if (ratio < 0.1) ratio = 0.1;            // mínimo de visibilidade

return {
  color: "#555",
  weight: 1,
  fillColor: getPartyColor(partidoIntensidade),
  fillOpacity: ratio
};


}

function onEachFeature(feature, layer) {
const key = distritoKey(feature);


const votosPartido =
  (resultados[partidoIntensidade] || {})[key] || 0;

const totalValidos =
  (resultados["VVE"] || {})[key] || 1;

const ratio = (votosPartido / totalValidos) * 100;

layer.bindTooltip(
  `${key}<br>${partidoIntensidade}: ${votosPartido.toLocaleString("pt-PT")} votos<br>` +
  `Peso no distrito: ${ratio.toFixed(1)}%`
);

layer.on("mouseover", () => layer.setStyle({ weight: 3 }));
layer.on("mouseout", () => layer.setStyle({ weight: 1 }));
layer.on("click", () => {
  viewof distritoSelecionado.value = key;
  map.fitBounds(layer.getBounds());
});

}

L.geoJSON(distritosGeo, { style, onEachFeature }).addTo(map);

return map;
}

```

```{ojs}
viewof tabelaPartidoDistrito = Inputs.table(
distritos.map(d => {
const votosPartido = ((resultados[partidoIntensidade] || {})[d] || 0);
const totalValidos = (resultados["VVE"] || {})[d] || 1;
const ratio = (votosPartido / totalValidos) * 100;
return {
distrito: d,
votos: votosPartido,
percentagem: ratio.toFixed(1)
};
}),
{ sort: "votos", reverse: true }
)
```

## Metricas Principais

```{ojs}
// Métricas principais
totalInscritos = resultados["Inscritos"]["Total"]
totalVotantes = resultados["Votantes"]["Total"]
abstNacional = 100 - (totalVotantes / totalInscritos) * 100

// Abstenção por distrito
abstPorDistrito = distritos.map(d => {
const insc = resultados["Inscritos"][d] || 1;
const vot = resultados["Votantes"][d] || 0;
const abst = 100 - (vot / insc) * 100;
return { distrito: d, abstencao: abst };
})

distritoMaiorAbst = abstPorDistrito.reduce((a, b) =>
b.abstencao > a.abstencao ? b : a
)
distritoMenorAbst = abstPorDistrito.reduce((a, b) =>
b.abstencao < a.abstencao ? b : a
)

// Partido mais votado a nível nacional
votosNacionaisPorPartido = partidos.map(p => ({
partido: p,
votos: (resultados[p] || {})["Total"] || 0
}))
partidoMaisVotadoNacional = votosNacionaisPorPartido.reduce((a, b) =>
b.votos > a.votos ? b : a
)

metricasHTML = html`

<div style="display:flex; flex-wrap:wrap; gap:1rem;">
  <div style="flex:1; min-width:220px; padding:1rem; border-radius:8px; background:#f5f5f5;">
    <strong>Taxa de abstenção nacional</strong><br>
    ${abstNacional.toFixed(1)}%
  </div>
  <div style="flex:1; min-width:220px; padding:1rem; border-radius:8px; background:#f5f5f5;">
    <strong>Maior abstenção</strong><br>
    ${distritoMaiorAbst.distrito}: ${distritoMaiorAbst.abstencao.toFixed(1)}%
  </div>
  <div style="flex:1; min-width:220px; padding:1rem; border-radius:8px; background:#f5f5f5;">
    <strong>Menor abstenção</strong><br>
    ${distritoMenorAbst.distrito}: ${distritoMenorAbst.abstencao.toFixed(1)}%
  </div>
  <div style="flex:1; min-width:220px; padding:1rem; border-radius:8px; background:#f5f5f5;">
    <strong>Partido mais votado (nacional)</strong><br>
    ${partidoMaisVotadoNacional.partido}: ${partidoMaisVotadoNacional.votos.toLocaleString("pt-PT")} votos
  </div>
</div>
`
```

## Visualização Hierárquica: Sunburst


```{ojs}
radius = 250

// === 1) Dados hierárquicos: Portugal -> Partidos (grandes + "Outros") -> Distritos ===

// votos nacionais por partido
sunburstVotosNac = partidos.map(p => ({
partido: p,
votos: (resultados[p] || {})["Total"] || 0
}))

sunburstTotalNac = sunburstVotosNac.reduce((acc, x) => acc + x.votos, 0)

// partidos com >= 2% dos votos nacionais
sunburstThreshold = 0.02

sunburstPartidosGrandes = sunburstVotosNac
.filter(x => (x.votos / sunburstTotalNac) >= sunburstThreshold)
.map(x => x.partido)

sunburstPartidosPequenos = sunburstVotosNac
.filter(x => (x.votos / sunburstTotalNac) < sunburstThreshold)
.map(x => x.partido)

// agregar votos dos partidos pequenos por distrito
sunburstOutrosPorDistrito = distritos.map(d => ({
nome: d,
valor: sunburstPartidosPequenos.reduce((acc, p) => {
return acc + ((resultados[p] || {})[d] || 0)
}, 0)
}))

// estrutura final
sunburstData = ({
name: "Portugal",
children: [
...sunburstPartidosGrandes.map(p => ({
name: p,
color: getPartyColor(p),
children: distritos.map(d => ({
name: d,
value: (resultados[p] || {})[d] || 0
}))
})),
{
name: "Outros",
color: "#bbbbbb",
children: sunburstOutrosPorDistrito.map(d => ({
name: d.nome,
value: d.valor
}))
}
]
})

// === 2) Layout helpers ===
partition = data => {
const root = d3.hierarchy(data)
.sum(d => d.value || 0)
.sort((a, b) => b.value - a.value)

return d3.partition()
.size([2 * Math.PI, radius])(root)
}

arc = d3.arc()
.startAngle(d => d.x0)
.endAngle(d => d.x1)
.innerRadius(d => d.y0)
.outerRadius(d => d.y1)

arcVisible = d =>
d.y1 <= radius && d.y0 >= 0 && d.x1 > d.x0

labelTransform = d => {
const x = (d.x0 + d.x1) / 2 * 180 / Math.PI
const y = (d.y0 + d.y1) / 2
return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`
}

// regra de visibilidade das labels:
// - foco em Portugal -> mostrar partidos (depth 1)
// - foco num partido  -> mostrar distritos (depth 2) desse partido
labelOpacity = (d, focus) => {
  if (!arcVisible(d.current)) return 0;

  const depthRel = d.depth - focus.depth; // 1 = um nível abaixo do foco

  // ---- Caso 1: foco em Portugal (root) ----
  if (focus.depth === 0) {
    // mostrar todos os partidos (depth = 1), esconder distritos
    return d.depth === 1 ? 1 : 0;
  }

  // ---- Caso 2: foco num partido ----
  if (depthRel !== 1) return 0; // só distritos

  // comprimento aproximado do arco em píxeis
  const r = (d.current.y0 + d.current.y1) / 2;
  const arcLen = (d.current.x1 - d.current.x0) * r;

  // limite MAIS BAIXO -> aparecem mais distritos com label
  if (arcLen < 6) return 0;

  return 1;
};



// === 3) Sunburst com zoom + labels arrumadas ===
sunburst = {
const root = partition(sunburstData)
root.each(d => d.current = d)

let focus = root // foco atual (Portugal)

const svg = d3.create("svg")

.attr("viewBox", [-radius, -radius, radius * 2, radius * 2])
.style("font-family", "system-ui, sans-serif")
.style("font-size", "10px")

const g = svg.append("g")

const centerLabel = svg.append("text")
  .attr("text-anchor", "middle")
  .attr("dy", "0.35em")
  .style("font-size", "12px")
  .style("fill", "#555")
  .text("Portugal")

  centerLabel.on("click", () => {
  if (focus !== root) clicked(null, root)
})

const path = g.append("g")
.selectAll("path")
.data(root.descendants().slice(1))
.join("path")
.attr("fill", d => {
let a = d
while (a.depth > 1) a = a.parent
return a.data.color || getPartyColor(a.data.name) || "#bbbbbb"
})
.attr("fill-opacity", d => arcVisible(d.current) ? (d.children ? 0.8 : 0.7) : 0)
.attr("pointer-events", d => arcVisible(d.current) ? "auto" : "none")
.attr("stroke", "#fff")
.attr("stroke-width", 0.5)
.attr("d", d => arc(d.current))

path.append("title")
.text(d => {
const pct = (d.value / root.value) * 100
return `${d.ancestors().map(x => x.data.name).reverse().join(" → ")}\n` +
`${d.value.toLocaleString("pt-PT")} votos (${pct.toFixed(2)}%)`
})

const label = g.append("g")
.attr("pointer-events", "none")
.attr("text-anchor", "middle")
.style("user-select", "none")
.selectAll("text")
.data(root.descendants().slice(1))
.join("text")
.attr("dy", "0.35em")
.attr("fill-opacity", d => labelOpacity(d, focus))
.attr("transform", d => labelTransform(d.current))
.text(d => d.data.name)

const parent = g.append("circle")
.datum(root)
.attr("r", radius * 0.3)
.attr("fill", "white")
.attr("pointer-events", "all")
.style("cursor", "pointer")
.on("click", clicked)

path.filter(d => d.children)
.style("cursor", "pointer")
.on("click", clicked)

function clicked(event, p) {
  // Se clicares outra vez no mesmo nó (e não é root), volta a Portugal
  if (p === focus && p !== root) {
    p = root
  }

  focus = p
  parent.datum(p.parent || root)

  // Atualizar o texto do centro
  if (p === root) {
    centerLabel.text("Portugal")
  } else {
    centerLabel.text(`Clique no centro para voltar`)
  }

  root.each(d => d.target = {
    x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
    x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
    y0: Math.max(0, d.y0 - p.y0),
    y1: Math.max(0, d.y1 - p.y0)
  })

  const t = g.transition().duration(750)

  path.transition(t)
    .tween("data", d => {
      const i = d3.interpolate(d.current, d.target)
      return t => d.current = i(t)
    })
    .filter(function (d) {
      return +this.getAttribute("fill-opacity") || arcVisible(d.target)
    })
    .attr("fill-opacity", d => arcVisible(d.current) ? (d.children ? 0.8 : 0.7) : 0)
    .attr("pointer-events", d => arcVisible(d.current) ? "auto" : "none")
    .attrTween("d", d => () => arc(d.current))

  label
    .filter(function (d) {
      return +this.getAttribute("fill-opacity") || labelOpacity(d, focus)
    })
    .transition(t)
    .attr("fill-opacity", d => labelOpacity(d, focus))
    .attrTween("transform", d => () => labelTransform(d.current))
}

return svg.node()

}

```